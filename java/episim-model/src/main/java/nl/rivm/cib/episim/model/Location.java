/* $Id$
 * 
 * Part of ZonMW project no. 50-53000-98-156
 * 
 * @license
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy
 * of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 * 
 * Copyright (c) 2016 RIVM National Institute for Health and Environment 
 */
package nl.rivm.cib.episim.model;

import java.util.Collection;
import java.util.HashSet;

import javax.measure.unit.NonSI;

import org.jscience.geography.coordinates.LatLong;
import org.opengis.spatialschema.geometry.geometry.Position;

import io.coala.time.x.Instant;
import nl.rivm.cib.episim.time.Timed;
import rx.Observable;
import rx.Observer;
import rx.subjects.PublishSubject;
import rx.subjects.Subject;

/**
 * {@link Location}
 * 
 * @version $Id$
 * @author Rick van Krevelen
 */
public interface Location extends Timed
{

	/** RIVM National Institute for Public Health and the Environment */
	Position RIVM = LatLong.valueOf( 52.1185272, 5.1868699,
			NonSI.DEGREE_ANGLE );

	/** @return the global {@link Position} of this {@link Location} */
	default Position getPosition()
	{
		return RIVM;
	}

	/**
	 * @return a {@link Collection} of current {@link Individual} occupants
	 */
	Collection<Individual> getOccupants();

	/** @param visitor the {@link Individual} arriving */
	void onArrival( Individual visitor );

	/** @param visitor the {@link Individual} departing */
	void onDeparture( Individual visitor );

	/**
	 * @return an {@link Observable} stream of {@link ContactEvent}s generated
	 *         by {@link Carrier} occupants of this {@link Location}
	 */
	Observable<ContactEvent> emitContacts();

	/**
	 * @return an {@link Observable} stream of {@link TransmissionEvent}s
	 *         generated by {@link Carrier} occupants of this {@link Location}
	 */
	Observable<TransmissionEvent> emitTransmissions();

	/**
	 * {@link Carrier}s staying at this {@link Location} may cause it to
	 * generate {@link ContactEvent}s based on available
	 * {@link TransmissionRoute}s (e.g. contaminated objects, food, water,
	 * blood, ...)
	 *
	 * @param locatio the {@link Location} of stay
	 * @param visitor the temporary occupant {@link Individual}
	 * @param arrival the {@link Instant} of arrival
	 * @param departure the {@link Instant} of departure
	 */
	public static void stay( final Location location, final Individual visitor,
		final Instant arrival, final Instant departure )
	{
		location.onArrival( visitor );
		// FIXME schedule later
		// FIXME generate contact events from overlapping occupant stays
		// FIXME generate transmission events
		location.onDeparture( visitor );
	}

	/**
	 * {@link SimpleInfection} is a {@link Infection} and {@link Observer} of
	 * {@link ContactEvent}s which in turn may trigger its transmission by
	 * generating {@link TransmissionEvent}s.
	 * 
	 * 
	 * @version $Id$
	 * @author Rick van Krevelen
	 */
	public abstract class SimpleLocation implements Location
	{

		private Collection<Individual> occupants = new HashSet<>();

		private final transient Subject<ContactEvent, ContactEvent> contacts = PublishSubject
				.create();

		private final transient Subject<TransmissionEvent, TransmissionEvent> transmissions = PublishSubject
				.create();

		@Override
		public void onArrival( final Individual visitor )
		{
			this.occupants.add( visitor );
		}

		@Override
		public void onDeparture( final Individual visitor )
		{
			this.occupants.remove( visitor );
		}

		@Override
		public Collection<Individual> getOccupants()
		{
			return this.occupants;
		}

		@Override
		public Observable<ContactEvent> emitContacts()
		{
			return this.contacts.asObservable();
		}

		@Override
		public Observable<TransmissionEvent> emitTransmissions()
		{
			return this.transmissions.asObservable();
		}
	}

}
